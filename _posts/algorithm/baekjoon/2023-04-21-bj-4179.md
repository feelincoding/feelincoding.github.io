---
layout: single
title: "[백준] 4179 불!, Go/Java"
date: "2023-04-21 00:00:00 +0900"
last_modified_at: "2023-04-21 00:00:00 +0900"
categories:
  - algorithm-baekjoon
tags:
  - 알고리즘
  - BFS
# toc_label: "목차"
# toc: true
# toc_sticky: true
---

<br/>

## 0. 들어가면서

> 불! 문제이다. <br>
> 시작점이 여러가지인 문제이다. <br>
> BFS문제이다.

## 1. Java

### 1.1 내가 푼 코드

```java
package bj.ch09_bfs;

import java.util.*;
import java.io.*;

public class BJ_4179_불_01 {
    /*
     * r*c = 1000000 이므로 대략 NlogN안에 끝내야 한다.
     * 지훈, 불 각각의 큐를 사용한다.
     * 지훈이는 불이 난 곳으로 이동할 수 없기 때문에 불 먼저 돌린다.
     * 지훈이는 거리까지 알아야한다.
     * 4 4
     * ####
     * #JF#
     * #..#
     * #..#
     */
    static Queue<int[]> fQ = new LinkedList<>();
    static Queue<int[]> jQ = new LinkedList<>();
    static char[][] map;
    static int[][] dist;
    static int R, C;

    static int[] dy = { -1, 1, 0, 0 }; // 상하좌우
    static int[] dx = { 0, 0, -1, 1 };

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        R = Integer.parseInt(st.nextToken());
        C = Integer.parseInt(st.nextToken());

        map = new char[R][C];
        dist = new int[R][C];

        for (int y = 0; y < R; y++) {
            String line = br.readLine();
            for (int x = 0; x < C; x++) {
                char c = line.charAt(x);
                map[y][x] = c;
                dist[y][x] = -1;
                if (c == 'J') {
                    jQ.offer(new int[] { y, x });
                    dist[y][x] = 0;
                }
                if (c == 'F') {
                    fQ.offer(new int[] { y, x });
                }
            }
        }

        while (!jQ.isEmpty()) {
            // 불 먼저 돌린다.
            int fSize = fQ.size();
            for (int fs = 0; fs < fSize; fs++) {
                int[] curF = fQ.poll();
                for (int d = 0; d < 4; d++) {
                    int nFy = curF[0] + dy[d];
                    int nFx = curF[1] + dx[d];
                    if (nIR(nFy, R) || nIR(nFx, C)) // 범위 초과
                        continue;
                    if (map[nFy][nFx] == '#') // 벽
                        continue;
                    if (map[nFy][nFx] == 'F') // 이미 불
                        continue;
                    map[nFy][nFx] = 'F'; // 불이 번져
                    fQ.offer(new int[] { nFy, nFx });
                }
            }
            // 지훈이 차례
            int jSize = jQ.size();
            for (int js = 0; js < jSize; js++) {
                int[] curJ = jQ.poll();
                for (int d = 0; d < 4; d++) {
                    int nJy = curJ[0] + dy[d];
                    int nJx = curJ[1] + dx[d];
                    if (nIR(nJy, R) || nIR(nJx, C)) { // 범위 초과
                        System.out.println(dist[curJ[0]][curJ[1]] + 1);
                        return;
                    }
                    if (map[nJy][nJx] == '#') { // 벽
                        continue;
                    }
                    if (map[nJy][nJx] == 'F') { // 불
                        continue;
                    }
                    if (dist[nJy][nJx] >= 0) { // 이미 방문
                        continue;
                    }
                    dist[nJy][nJx] = dist[curJ[0]][curJ[1]] + 1;
                    jQ.offer(new int[] { nJy, nJx });
                }
            }
        }
        System.out.println("IMPOSSIBLE");
    }

    private static boolean nIR(int v, int range) {
        return (v < 0 || v >= range) ? true : false;
    }
}


```

### 1.3 바킹독을 참고한 코드

```java
// 풀 예정
```

### 1.4 해설

- 시작점이 여러개이고, 거리를 구해야하는 문제이다.
- 불을 먼저 퍼뜨리고, 지훈이를 퍼뜨린다.
- 이 과정에서 불필요한 변수를 줄일 수 있지 않을까?
- 좀 더 빨리 반복문을 빠져나올 수 있지 않을까에 대해서 생각해보았다.

## 2. Go

## CLOSING

> 재활훈련 필요<br>
